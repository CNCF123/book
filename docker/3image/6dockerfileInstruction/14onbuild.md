## ONBUILD {#onbuild}

* `ONBUILD [INSTRUCTION] `

当图像用作另一个构建的基础时，该`ONBUILD`指令向图像添加将在稍后执行的_触发_指令。触发器将在下游构建的上下文中执行，就好像它已经`FROM`在下游指令之后立即插入一样`Dockerfile`。

任何构建指令都可以注册为触发器。

如果要构建将用作构建其他映像的基础的映像（例如，可以使用特定于用户的配置自定义的应用程序构建环境或守护程序），这将非常有用。

例如，如果您的映像是可重用的Python应用程序构建器，则需要将应用程序源代码添加到特定目录中，并且可能需要_在_此_之后_调用构建脚本。你不能只是打电话`ADD`和`RUN`现在，因为你还没有访问应用程序的源代码，这将是为每个应用程序生成不同的。您可以简单地为应用程序开发人员提供`Dockerfile`复制粘贴到他们的应用程序中的样板，但这样做效率低，容易出错且难以更新，因为它与特定于应用程序的代码混合在一起。

解决方案是用于`ONBUILD`在下一个构建阶段注册预先指令以便稍后运行。

以下是它的工作原理：

1. 当遇到
   `ONBUILD`
   指令时，构建器会向正在构建的图像的元数据添加触发器。
   该指令不会影响当前构建。
2. 在构建结束时，所有触发器的列表存储在键下的图像清单中
   `OnBuild`
   。
   可以使用该
   `docker inspect`
   命令
   检查它们
   。
3. 稍后，可以使用该
   `FROM`
   指令
   将图像用作新构建的基础
   。
   作为处理
   `FROM`
   指令的
   一部分
   ，下游构建器查找
   `ONBUILD`
   触发器，并按照它们注册的顺序执行它们。
   如果任何触发器失败，
   `FROM`
   则中止指令，这反过来导致构建失败。
   如果所有触发器都成功，则
   `FROM`
   指令完成并且构建继续照常进行。
4. 执行后，触发器将从最终图像中清除。
   换句话说，它们不是由“大孩子”构建继承的。

例如，您可以添加以下内容：

```
[...]

ONBUILD ADD . /app/src

ONBUILD RUN /usr/local/bin/python-build --dir /app/src

[...]
```

> **警告**：不允许`ONBUILD`使用链接指令`ONBUILD ONBUILD`。
>
> **警告**：`ONBUILD`指令可能不会触发`FROM`或`MAINTAINER`指令。



